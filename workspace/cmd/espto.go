// Assumptions:
// - RDS calls return nothing and can always be async
// - All IDs are randomly generated byte strings / byte arrays
// - The latest AWS Go SDK is acceptable
// - Mocking calls are allows
// - Constant SQL statements can be left empty
// - The batch execution can be blocking
// - If essential information is missing to handle the transaction failing the operation is acceptable to avoid erroneous transaction records
package cmd

import (
	"context"
	"fmt"
	"os"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/rdsdata"
	rdstypes "github.com/aws/aws-sdk-go-v2/service/rdsdata/types"
	"purs.example.com/m/ops"
	"purs.example.com/m/pkg"
	"purs.example.com/m/pkg/gen"
	"purs.example.com/m/types"
)

type RDS struct {
	Client *rdsdata.Client
}

const InsertFedNowPaymentSQL = ""
const InsertPaymentSQL = ""

// Creates everything necessary to record a transaction bundle in the RDS database
// returns the PrimaryPaymentID and CustomerLedgerEntryID
func (r *RDS) ExecutePTOps(usrPurch types.UserPurchaseInformation, promoAmount int, sqlTransctionID string) ([]byte, []byte) {

	var (
		ops                    ops.PTOperations
		primaryFedNowPaymentId []byte
		parameterSets          []rdstypes.SqlParameter
	)

	resourceArn := os.Getenv("RESOURCE_ARN")
	secretArn := os.Getenv("SECRET_ARN")
	database := os.Getenv("DATABASE")

	errCh := make(chan error)

	pursTransactionID := gen.RandBytes(32)

	ops.Init(sqlTransctionID, resourceArn, secretArn, database)

	statement := ops.BuildCardParams(usrPurch, InsertPaymentSQL)

	go PursExecute(r.Client, statement, errCh)

	if usrPurch.PaymentMethod == pkg.FedNow && usrPurch.Amount > 0 {
		fedNowPaymentId := gen.RandBytes(32)

		statement := ops.BuildFedNowParams(usrPurch, fedNowPaymentId, InsertFedNowPaymentSQL)
		primaryFedNowPaymentId = fedNowPaymentId
		fmt.Println(primaryFedNowPaymentId)

		go PursExecute(r.Client, statement, errCh)
	}

	if promoAmount > 0 {
		ledgerID := gen.RandBytes(32)
		statement := ops.BuildLedgerParams(usrPurch, ledgerID, promoAmount, InsertFedNowPaymentSQL)

		go PursExecute(r.Client, statement, errCh)
	}

	for _, pursPayment := range ops.LedgeEntries {
		txId := rdstypes.SqlParameter{
			Name: aws.String("TransactionId"),
			Value: &rdstypes.FieldMemberBlobValue{
				Value: pursTransactionID,
			},
		}

		ledgerId := rdstypes.SqlParameter{
			Name: aws.String("LedgerId"),
			Value: &rdstypes.FieldMemberBlobValue{
				Value: pursPayment,
			},
		}

		parameterSets = append(parameterSets, txId, ledgerId)
	}

	ops.ClearParams()

	batchStatement := ops.BuildBatch("", parameterSets)
	_, err := r.Client.BatchExecuteStatement(context.TODO(), &batchStatement)

	if err != nil {
		fmt.Println(err)
	}

	if err := errCh; err != nil {
		fmt.Println(err)
	}

	return pursTransactionID, ops.LedgerEntryId
}

// Async execution of statements with error handling
func PursExecute(client *rdsdata.Client, statement *rdsdata.ExecuteStatementInput, ch chan error) {
	_, err := client.ExecuteStatement(context.TODO(), statement)
	if err != nil {
		// Decent place for async handling logging
		ch <- err
	}

}
